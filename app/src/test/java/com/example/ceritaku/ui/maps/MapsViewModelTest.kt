package com.example.ceritaku.ui.mapsimport androidx.arch.core.executor.testing.InstantTaskExecutorRuleimport androidx.lifecycle.MutableLiveDataimport com.example.ceritaku.data.AppRepositoryimport com.example.ceritaku.data.Resultimport com.example.ceritaku.model.ResponseStoryimport com.example.ceritaku.utils.DataDummyimport com.example.ceritaku.utils.getOrAwaitValueimport org.junit.Assertimport org.junit.Beforeimport org.junit.Ruleimport org.junit.Testimport org.junit.runner.RunWithimport org.mockito.Mockimport org.mockito.Mockitoimport org.mockito.junit.MockitoJUnitRunner@RunWith(MockitoJUnitRunner::class)class MapsViewModelTest {    @get:Rule    val instantExecutorRule = InstantTaskExecutorRule()    @Mock    private lateinit var appRepository: AppRepository    private lateinit var mapsViewModel: MapsViewModel    private var dataDummy = DataDummy.generateDummyDataStory()    @Before    fun setup(){        mapsViewModel = MapsViewModel(appRepository)    }    @Test    fun `when Get Story Should Not Null and Return Success`() {        val expectedResponse = MutableLiveData<Result<ResponseStory>>()        expectedResponse.value = Result.Success(dataDummy)        Mockito.`when`(appRepository.getStoriesMap()).thenReturn(expectedResponse)        val actual = mapsViewModel.getStoriesMap().getOrAwaitValue()        Mockito.verify(appRepository).getStoriesMap()        Assert.assertNotNull(actual)        Assert.assertTrue(actual is Result.Success)    }    @Test    fun `when Get Story Should Null and Return Error`() {        dataDummy = DataDummy.generateDummyErrorDataStory()        val expected = MutableLiveData<Result<ResponseStory>>()        expected.value = Result.Error("error")        Mockito.`when`(appRepository.getStoriesMap()).thenReturn(expected)        val actual = mapsViewModel.getStoriesMap().getOrAwaitValue()        Mockito.verify(appRepository).getStoriesMap()        Assert.assertNotNull(actual)        Assert.assertTrue(actual is Result.Error)    }}