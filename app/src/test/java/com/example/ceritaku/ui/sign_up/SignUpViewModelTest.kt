package com.example.ceritaku.ui.sign_upimport androidx.arch.core.executor.testing.InstantTaskExecutorRuleimport androidx.lifecycle.MutableLiveDataimport com.example.ceritaku.data.AppRepositoryimport com.example.ceritaku.data.Resultimport com.example.ceritaku.model.ResponseRegisterimport com.example.ceritaku.utils.DataDummyimport com.example.ceritaku.utils.getOrAwaitValueimport org.junit.Assertimport org.junit.Beforeimport org.junit.Ruleimport org.junit.Testimport org.junit.runner.RunWithimport org.mockito.Mockimport org.mockito.Mockitoimport org.mockito.junit.MockitoJUnitRunner@RunWith(MockitoJUnitRunner::class)class SignUpViewModelTest {    @get: Rule    val instantExecutorRule = InstantTaskExecutorRule()    @Mock    private lateinit var appRepository: AppRepository    private lateinit var signUpViewModel: SignUpViewModel    private var dummyResponseRegister = DataDummy.generateDummySuccesRegister()    private val dataDummyName = "name"    private val dataDummyEmail = "email"    private val dataDummyPassword = "password"    @Before    fun setup(){        signUpViewModel = SignUpViewModel(appRepository)    }    @Test    fun `when Post Register Should Not Null and Return Success`(){        val expectedSignUp = MutableLiveData<Result<ResponseRegister>>()        expectedSignUp.value = Result.Success(dummyResponseRegister)        Mockito.`when`(appRepository.authRegister(dataDummyName,dataDummyEmail,dataDummyPassword)).thenReturn(expectedSignUp)        val actualResponse = signUpViewModel.register(dataDummyName,dataDummyEmail,dataDummyPassword).getOrAwaitValue()        Mockito.verify(appRepository).authRegister(dataDummyName,dataDummyEmail,dataDummyPassword)        Assert.assertNotNull(actualResponse)        Assert.assertTrue(actualResponse is Result.Success)    }    @Test    fun `when Post Register Should Null and Return Error`(){        dummyResponseRegister = DataDummy.generateDummyErrorResgister()        val expectedSignUp = MutableLiveData<Result<ResponseRegister>>()        expectedSignUp.value = Result.Error("Email is already taken")        Mockito.`when`(appRepository.authRegister(dataDummyName,dataDummyEmail,dataDummyPassword)).thenReturn(expectedSignUp)        val actualResponse = signUpViewModel.register(dataDummyName,dataDummyEmail,dataDummyPassword).getOrAwaitValue()        Mockito.verify(appRepository).authRegister(dataDummyName,dataDummyEmail,dataDummyPassword)        Assert.assertNotNull(actualResponse)        Assert.assertTrue(actualResponse is Result.Error)    }}