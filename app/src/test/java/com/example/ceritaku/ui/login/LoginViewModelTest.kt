package com.example.ceritaku.ui.loginimport androidx.arch.core.executor.testing.InstantTaskExecutorRuleimport androidx.lifecycle.MutableLiveDataimport com.example.ceritaku.data.AppRepositoryimport com.example.ceritaku.data.Resultimport com.example.ceritaku.model.ResponseLoginimport com.example.ceritaku.utils.DataDummyimport com.example.ceritaku.utils.getOrAwaitValueimport org.junit.Assertimport org.junit.Beforeimport org.junit.Ruleimport org.junit.Testimport org.junit.runner.RunWithimport org.mockito.Mockimport org.mockito.Mockitoimport org.mockito.Mockito.`when`import org.mockito.junit.MockitoJUnitRunner@RunWith(MockitoJUnitRunner::class)class LoginViewModelTest {    @get:Rule    val instantExecutorRUle = InstantTaskExecutorRule()    @Mock    private lateinit var appRepository: AppRepository    private lateinit var loginViewModel: LoginViewModel    private var dummyLoginResponse = DataDummy.generateDummySuccesLogin()    private val dataDummyEmail = "email"    private val dataDummyPassword = "password"    @Before    fun setup(){        loginViewModel = LoginViewModel(appRepository)    }    @Test    fun `when Post Login Should Not Null and Return Success`(){        val expectedLogin = MutableLiveData<Result<ResponseLogin>>()        expectedLogin.value = Result.Success(dummyLoginResponse)        `when`(appRepository.autLogin(dataDummyEmail, dataDummyPassword)).thenReturn(expectedLogin)        val actualResponse = loginViewModel.authLogin(dataDummyEmail, dataDummyPassword).getOrAwaitValue()        Mockito.verify(appRepository).autLogin(dataDummyEmail, dataDummyPassword)        Assert.assertNotNull(actualResponse)        Assert.assertTrue(actualResponse is Result.Success)    }    @Test    fun `when Post Login Should Null and Return Error`(){        dummyLoginResponse = DataDummy.generateDummyErrorLogin()        val expectedLogin = MutableLiveData<Result<ResponseLogin>>()        expectedLogin.value = Result.Error("password invalid")       `when`(appRepository.autLogin(dataDummyEmail, dataDummyPassword)).thenReturn(expectedLogin)        val actualResponse = loginViewModel.authLogin(dataDummyEmail,dataDummyPassword).getOrAwaitValue()        Mockito.verify(appRepository).autLogin(dataDummyEmail,dataDummyPassword)        Assert.assertNotNull(actualResponse)        Assert.assertTrue(actualResponse is Result.Error)    }}